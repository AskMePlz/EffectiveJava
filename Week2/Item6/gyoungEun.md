# [item6] 불필요한 객체 생성을 피하라

똑같은 기능의 객체를 매번 생성하기 보다는 객체 하나를 재사용하는게 나은 경우도 많다. 

## String 객체 생성

 new 키워드로 String 객체를 생성할때는 매번 새로운 객체를 생성한다. 리터럴로 String 객체를 생성할 때는 constant pool이 중복된 값이 있는지 확인하고 중복 값이 있을 경우 새로 잡힌 heap 영역을 해제하고 기존에 있던 인스턴스의 주소를 리턴함으로서 새로 생성한 변수가 해당 주소값을 바라보게 하여 불필요한 객체 생성을 피할 수 있게 한다.

## 생성자 대신 정적 팩터리 메서드를 제공하는 불변 클래스

 이는 정적 팩터리 메서드를 사용해 불필요한 객체 생성을 피할 수 있다. 예를 들어 `Boolean(String)` 보다는 `Boolean.valueOf(String)` 팩터리 메서드를 사용하는게 좋다. 

```java
public static Boolean valueOf(boolean b) {
    return (b ? TRUE : FALSE);
}
```

위 코드는 Boolean 클래스의  valueOf 메소드이다. 이 코드에서는 새로운 인스턴스를 만들어 반환하지 않는 걸 볼 수 있다. 반면에 생성자를 이용했으면 어땠을까? 실행할때마다 객체가 생성됐을 것이다.

## 생성비용이 비싼 객체

생성비용이 비싼데 반복해서 필요한 경우, 캐싱해서 사용하자. (값비싼 객체를 재사용해 성능을 개선하자)

## 오토박싱(auto boxing)

박싱된 기본 타입 보다는 기본타입을 사용하고 의도치 않은 오토박싱이 안되게 하는게 좋다.

```java
public long sum() {
  Long sum = 0L; // (a)
  for (long i = 0 ; i<= Integer.MAX_VALUE; i++){
     sum+= i; // (b) 
  }
  return sum;   
}
```

(a) 부분에 Long으로 sum을 선언했기 때문에 (b)부분에서 연산을 수행하면서 계속해서 새로운 객체를 만든다. 

(b)부분을 다르게 표현하면  `sum = new Long(sum + i);` 라고 할 수 있다. 위의 코드는 (a)를 `long sum = 0L` 로 바꾸면 1/5의 속도로 실행할 수 있다.
