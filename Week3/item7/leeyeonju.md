> 객체를 올바르게 생성파고 적절히 파괴하는 법을 배우는 장의 마지막 아이템이다. 앞서 정적 팩터리 메서드로 생성자를 만든다거나, 생성자를 빌더로 만든다거나, 싱글턴 객체를 만드는 법을 배웠다. 언제 어떠한 방법으로 객체를 만들고 사용하는게 효율적인지 불필요한 객체 생성을 피하는 방법을 배운것이다. 불필요한 객체 생성을 피하는것 만큼 중요한것이 적절히 파괴하는 것이다. JVM을 통해 가비지 컬렉터가 주기적으로 사용하지 않는 객체는 알아서 정리하지만 이 GC 손이 닿지 못하는 곳에 메모리 누수가 발생할 수 있다. 그 지점을 찾아서 적절히 파괴해 주고, 괜히 사용하여 문제가 발생할 수 있는 자바의 기능까지 알아보자. 또한 이를 해결할 다양한 방법도 찾아보자
> 

## 더이상 사용하지 않는 참조를 찾아 적절히 파괴해주자.

일반 적으로는 더이상 참조하지 않는 경우네 해당 객체를 정리한다. 그러나! 

- 흔히 발생하는 케이스
    - 스택 사용시 ! pop으로 제거 하더래도 제거된 객체의 다 쓴 참조 주소가 여전히 존재한다
        
        pop()은 size를 줄여서 객체를 반환하기 때문에 지워진 size 인덱스의 객체를 그대로 살아있다. (size 범위 밖에 객체들) 
        
        ```json
        // 가장 최근 쌓인 객체 반환 (제거)
        public Object pop() {
            if(size == 0) {
                throw new EmptyStackException();
            }
            return elements[--size];
        }
        ```
        
        ```java
        public Object pop_개선() {
            if(size == 0) {
                throw new EmptyStackException();
            }
            Object object = elements[--size];
            elements[size] = null; // 삭제한 객체는 지워주기 
            return object;
        }
        ```
        
    - 리스트 사용시 ! 리스트 내부에 수많은 사용하지 않는 객체가 남아 더이상 사용되지 않더라고 이러한 객체를 수거해 가지는 않는다.

## 메모리 누수의 주범을 알아보자.

- 자기 메모리를 직접 관리하는 클래스에서 역할을 다하지 못하는 경우
- 캐시 관리가 제대로 안될 경우
- 리스너와 콜백 관리가 제대로 안될 경우

## 피해야 하는 기능! finalizer, cleaner

- 왜 ?
- 그렇다면 ?

## 추천하는 방법! try-finally 대신 try-with-resources

- 왜?
